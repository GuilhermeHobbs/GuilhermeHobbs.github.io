<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Responsive Interactive Checkers</title>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        margin: 0;
        font-family: 'Arial', sans-serif;
        position: relative;
        overflow-x: hidden;
        padding: 20px;
    }

    /* Animated background pattern */
    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: 
            radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
            radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
            radial-gradient(circle at 40% 40%, rgba(120, 119, 198, 0.2) 0%, transparent 50%);
        animation: float 20s ease-in-out infinite;
        z-index: -1;
    }

    @keyframes float {
        0%, 100% { transform: translateY(0px) rotate(0deg); }
        33% { transform: translateY(-20px) rotate(1deg); }
        66% { transform: translateY(10px) rotate(-1deg); }
    }

    .game-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        display: flex;
        align-items: center;
        gap: 40px;
        max-width: 1200px;
    }

    .board-container {
        width: 70vmin;
        height: 70vmin;
        max-width: 500px;
        max-height: 500px;
        position: relative;
        flex-shrink: 0;
    }

    .side-panel {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
        min-width: 250px;
    }

    .board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        grid-template-rows: repeat(8, 1fr);
        width: 100%;
        height: 100%;
        border: 5px solid #2c3e50;
        border-radius: 10px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .square {
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: calc(70vmin / 16);
        font-weight: bold;
        z-index: 0;
        position: relative;
        transition: all 0.3s ease;
    }

    .black {
        background-color: #8b4513;
        color: #f4f4f4;
        background-image: 
            linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%), 
            linear-gradient(-45deg, rgba(0,0,0,0.1) 25%, transparent 25%);
        background-size: 4px 4px;
    }

    .white {
        background-color: #f5deb3;
        color: #8b4513;
        font-weight: 600;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }

    .square:hover {
        filter: brightness(1.1);
    }

    .piece {
        width: 12%;
        height: 12%;
        border-radius: 50%;
        position: absolute;
        cursor: grab;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: calc(70vmin / 15);
        font-weight: bold;
        opacity: 0.9;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .piece:hover {
        transform: scale(1.1);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    .red {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        color: white;
        border: 3px solid #a93226;
    }

    .gray {
        background: linear-gradient(145deg, #95a5a6, #7f8c8d);
        color: white;
        border: 3px solid #5d6d7e;
    }

    .piece:active {
        cursor: grabbing;
        transform: scale(0.95);
    }

    .frozen {
        pointer-events: none;
        opacity: 0.7;
    }

    .game-title {
        text-align: center;
        color: white;
        font-size: 2.5em;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        letter-spacing: 2px;
        margin-bottom: 10px;
    }

    #newGameBtn {
        background: linear-gradient(145deg, #3498db, #2980b9);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 18px;
        font-weight: bold;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
        position: relative;
        overflow: hidden;
        min-width: 150px;
    }

    #newGameBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4);
        background: linear-gradient(145deg, #5dade2, #3498db);
    }

    #newGameBtn:active {
        transform: translateY(0);
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
    }

    #newGameBtn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }

    #newGameBtn:hover::before {
        left: 100%;
    }

    .empty-board-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: rgba(139, 69, 19, 0.6);
        font-size: 1.2em;
        font-weight: bold;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
    }

    @media (max-width: 1024px) {
        .game-container {
            flex-direction: column;
            gap: 20px;
            padding: 20px;
        }
        
        .board-container {
            width: 80vmin;
            height: 80vmin;
        }
        
        .side-panel {
            min-width: auto;
            gap: 20px;
        }
    }

    @media (max-width: 768px) {
        .game-container {
            padding: 15px;
            margin: 10px;
        }
        
        .board-container {
            width: 85vmin;
            height: 85vmin;
            max-width: 400px;
            max-height: 400px;
        }
        
        .game-title {
            font-size: 2em;
        }
        
        #newGameBtn {
            padding: 12px 24px;
            font-size: 16px;
        }
    }

    @media (max-width: 480px) {
        .board-container {
            width: 90vmin;
            height: 90vmin;
            max-width: 350px;
            max-height: 350px;
        }
        
        .game-title {
            font-size: 1.5em;
        }
    }

    /* Loading animation */
    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255,255,255,.3);
        border-radius: 50%;
        border-top-color: #fff;
        animation: spin 1s ease-in-out infinite;
        margin-left: 10px;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
</style>
</head>
<body>
    <div class="game-container">
        <div class="board-container">
            <div class="board" id="board">
                <div class="empty-board-message" id="emptyMessage">
                    Clique em "Novo Jogo" para começar
                </div>
            </div>
        </div>
        <div class="side-panel">
            <h1 class="game-title">Jogo de Damas</h1>
            <button id="newGameBtn">
                <span id="btnText">Novo Jogo</span>
            </button>
        </div>
    </div>
    
    <script>
    // Wait for DOM to be fully loaded
    document.addEventListener("DOMContentLoaded", () => {
        let gameInitialized = false;
        initializeEmptyBoard();
        
        // New Game button functionality
        document.getElementById("newGameBtn").addEventListener("click", () => {
            if (!gameInitialized) {
                initializeGame();
                gameInitialized = true;
            } else {
                restartGame();
            }
        });
    });

    function initializeEmptyBoard() {
        const board = document.getElementById("board");
        const boardSize = 8;
        let whiteCounter = 32;
        
        // Clear board and show empty message
        board.innerHTML = '<div class="empty-board-message" id="emptyMessage">Clique em "Novo Jogo" para começar</div>';
        
        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                let square = document.createElement("div");
                square.classList.add("square");

                if ((row + col) % 2 === 0) {
                    square.classList.add("black");
                    square.innerText = "";
                } else {
                    square.classList.add("white");
                    square.dataset.position = whiteCounter;
                    square.innerText = ""; // Don't show numbers initially
                    whiteCounter--;
                }

                board.appendChild(square);
            }
        }
    }

    function showLoading() {
        const btnText = document.getElementById("btnText");
        btnText.innerHTML = 'Iniciando... <div class="loading"></div>';
        document.getElementById("newGameBtn").disabled = true;
    }

    function hideLoading() {
        const btnText = document.getElementById("btnText");
        btnText.textContent = "Novo Jogo";
        document.getElementById("newGameBtn").disabled = false;
    }

    function restartGame() {
        showLoading();
        
        // Clear existing pieces
        Object.values(pieces).forEach(piece => {
            piece.remove();
        });
        pieces = {};
        
        const url = `https://palamedes.onrender.com/move?move=`;
        fetch(url)
            .then(response => {
                console.log("New game request sent");
                return response.text();
            })
            .then(data => {
                console.log("Response received:", data);
                hideLoading();
                // Recreate pieces
                createPieces();
            })
            .catch(error => {
                console.error("Error sending new game request:", error);
                hideLoading();
                // Still create pieces even if API fails
                createPieces();
            });
    }

    function initializeGame() {
        showLoading();
        
        // Hide empty message
        const emptyMessage = document.getElementById("emptyMessage");
        if (emptyMessage) {
            emptyMessage.style.display = "none";
        }
        
        // Initialize game with API call
        const url = `https://palamedes.onrender.com/move?move=`;
        fetch(url)
            .then(response => {
                console.log("New game request sent");
                return response.text();
            })
            .then(data => {
                console.log("Response received:", data);
                hideLoading();
                setupGameLogic();
            })
            .catch(error => {
                console.error("Error sending new game request:", error);
                hideLoading();
                // Initialize game even if API fails
                setupGameLogic();
            });
    }

    function setupGameLogic() {
        const board = document.getElementById("board");
        const boardContainer = document.querySelector(".board-container");

        const boardSize = 8;
        const grayPieces = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];
        const redPieces = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
        
        let boardFrozen = false;
        let whiteSquares = {};

        // Track multi-jump sequences
        let jumpSequence = null;
        let jumpTimer = null;
        let lastMovedPiece = null;
        const JUMP_TIMEOUT = 4000;

        let pieceLocations = {};
        let piecesByPosition = {};

        function updatePieceLocations() {
            pieceLocations = {};
            piecesByPosition = {};
            
            Object.entries(pieces).forEach(([id, piece]) => {
                const position = parseInt(piece.dataset.position);
                pieceLocations[id] = position;
                piecesByPosition[position] = piece;
            });
        }

        function rebuildPiecesState() {
            let positionsOccupied = {};
            let piecesToRemove = [];
            
            Object.entries(pieces).forEach(([id, piece]) => {
                const position = parseInt(piece.dataset.position);
                if (positionsOccupied[position]) {
                    piecesToRemove.push(id);
                } else {
                    positionsOccupied[position] = id;
                }
            });
            
            piecesToRemove.forEach(id => {
                if (pieces[id]) {
                    pieces[id].remove();
                    delete pieces[id];
                }
            });
            
            updatePieceLocations();
        }

        function removePieceAtPosition(position) {
            position = parseInt(position);
            let pieceToRemove = piecesByPosition[position];
            
            if (!pieceToRemove) {
                pieceToRemove = Object.values(pieces).find(piece => 
                    parseInt(piece.dataset.position) === position);
            }
            
            if (pieceToRemove) {
                console.log(`Removing piece at position ${position}`);
                pieceToRemove.style.transition = "opacity 0.5s ease";
                pieceToRemove.style.opacity = "0";
                
                const pieceId = Object.keys(pieces).find(id => pieces[id] === pieceToRemove);
                
                setTimeout(() => {
                    pieceToRemove.remove();
                    if (pieceId) {
                        delete pieces[pieceId];
                    }
                    updatePieceLocations();
                }, 500);
                
                return true;
            }
            
            console.warn(`No piece found at position ${position} to remove`);
            return false;
        }

        function positionPiece(piece, position, animated = false) {
            let square = document.querySelector(`[data-position="${position}"]`);
            if (!square) {
                console.error(`Square with data-position="${position}" not found`);
                return;
            }
            
            let rect = square.getBoundingClientRect();
            let boardRect = boardContainer.getBoundingClientRect();
            let size = boardRect.width / 8;

            if (animated) {
                piece.style.transition = "left 0.8s ease, top 0.8s ease";
            } else {
                piece.style.transition = "none";
            }

            piece.style.width = `${size * 0.75}px`;
            piece.style.height = `${size * 0.75}px`;
            piece.style.left = `${rect.left + window.scrollX + size * 0.125}px`;
            piece.style.top = `${rect.top + window.scrollY + size * 0.125}px`;
            piece.style.position = "absolute";
            
            if (!animated) {
                void piece.offsetWidth;
            }
        }

        function updatePiecePositions() {
            Object.values(pieces).forEach(piece => {
                let position = piece.dataset.position;
                positionPiece(piece, position, false);
            });
            
            updatePieceLocations();
        }

        let draggedPiece = null;
        let offsetX = 0, offsetY = 0;
        let initialPosition = null;

        function dragStart(event) {
            if (boardFrozen) return;
            draggedPiece = event.target;
            initialPosition = draggedPiece.dataset.position;
            offsetX = event.clientX - draggedPiece.getBoundingClientRect().left;
            offsetY = event.clientY - draggedPiece.getBoundingClientRect().top;

            document.addEventListener("mousemove", dragMove);
            document.addEventListener("mouseup", dragEnd);
        }

        function dragMove(event) {
            if (!draggedPiece || boardFrozen) return;

            draggedPiece.style.left = `${event.clientX - offsetX}px`;
            draggedPiece.style.top = `${event.clientY - offsetY}px`;
        }

        function dragEnd(event) {
            if (!draggedPiece || boardFrozen) return;

            let closestSquare = null;
            let minDistance = Infinity;

            document.querySelectorAll(".white").forEach(square => {
                let rect = square.getBoundingClientRect();
                let centerX = rect.left + rect.width / 2;
                let centerY = rect.top + rect.height / 2;
                let distance = Math.hypot(
                    centerX - (draggedPiece.getBoundingClientRect().left + draggedPiece.clientWidth / 2),
                    centerY - (draggedPiece.getBoundingClientRect().top + draggedPiece.clientHeight / 2)
                );

                if (distance < minDistance) {
                    minDistance = distance;
                    closestSquare = square;
                }
            });

            if (closestSquare) {
                let newPosition = parseInt(closestSquare.dataset.position);
                let fromPosition = parseInt(initialPosition);
                
                if (newPosition !== fromPosition) {
                    positionPiece(draggedPiece, newPosition, false);
                    draggedPiece.dataset.position = newPosition;

                    if (Math.abs(fromPosition - newPosition) > 5) {
                        let pieceToRemovePos;
                        if ((fromPosition + newPosition) % 16 < 8) {
                            pieceToRemovePos = Math.floor((fromPosition + newPosition) / 2);
                        } else {
                            pieceToRemovePos = Math.ceil((fromPosition + newPosition) / 2);
                        }
                        
                        removePieceAtPosition(pieceToRemovePos);
                        sendMoveRequest(fromPosition, newPosition, true);
                    } else {
                        sendMoveRequest(fromPosition, newPosition, false);
                    }
                } else {
                    positionPiece(draggedPiece, fromPosition, false);
                    console.log("Piece clicked but not moved to a different square");
                }
            } else {
                positionPiece(draggedPiece, initialPosition, false);
            }

            draggedPiece = null;
            document.removeEventListener("mousemove", dragMove);
            document.removeEventListener("mouseup", dragEnd);
        }

        function freezeBoard() {
            boardFrozen = true;
            document.body.classList.add("frozen");
        }

        function unfreezeBoard() {
            boardFrozen = false;
            document.body.classList.remove("frozen");
        }

        function processMoveSequence(parts, startIndex) {
            if (startIndex >= parts.length - 2) return;
            
            const responseFrom = parseInt(parts[startIndex]);
            const responseTo = parseInt(parts[startIndex + 2]);
            
            if (isNaN(responseFrom) || isNaN(responseTo)) return;
            
            let pieceToMove = piecesByPosition[responseFrom];
            
            if (!pieceToMove) {
                pieceToMove = Object.values(pieces).find(piece => 
                    parseInt(piece.dataset.position) === responseFrom);
            }
            
            if (!pieceToMove) {
                console.warn(`No piece found at position ${responseFrom}`);
                if (startIndex + 4 < parts.length && parts[startIndex + 3] === "33") {
                    setTimeout(() => {
                        processMoveSequence(parts, startIndex + 2);
                    }, 800);
                }
                return;
            }
            
            console.log(`Moving piece from ${responseFrom} to ${responseTo} based on API jump response`);
            
            let pieceToRemovePos;
            if ((responseFrom + responseTo) % 16 < 8) {
                pieceToRemovePos = Math.floor((responseFrom + responseTo) / 2);
            } else {
                pieceToRemovePos = Math.ceil((responseFrom + responseTo) / 2);
            }
            
            setTimeout(() => {
                pieceToMove.dataset.position = responseTo;
                positionPiece(pieceToMove, responseTo, true);
                
                setTimeout(() => {
                    updatePieceLocations();
                    const pieceCaptured = removePieceAtPosition(pieceToRemovePos);
                    
                    if (startIndex + 4 < parts.length && parts[startIndex + 3] === "33") {
                        setTimeout(() => {
                            processMoveSequence(parts, startIndex + 2);
                        }, pieceCaptured ? 500 : 300);
                    }
                }, 400);
            }, 50);
        }

        function processApiResponse(data) {
            console.log("Response received:", data);
            
            if (data && data.includes('-')) {
                rebuildPiecesState();
                
                if (data.includes('-33-')) {
                    const parts = data.split('-');
                    processMoveSequence(parts, 0);
                } else {
                    const [responseFrom, responseTo] = data.split('-').map(Number);
                    if (!isNaN(responseFrom) && !isNaN(responseTo)) {
                        let pieceToMove = piecesByPosition[responseFrom];
                        
                        if (!pieceToMove) {
                            pieceToMove = Object.values(pieces).find(piece => 
                                parseInt(piece.dataset.position) === responseFrom);
                        }
                        
                        if (pieceToMove) {
                            console.log(`Moving piece from ${responseFrom} to ${responseTo} based on API response`);
                            pieceToMove.dataset.position = responseTo;
                            
                            setTimeout(() => {
                                positionPiece(pieceToMove, responseTo, true);
                                
                                setTimeout(() => {
                                    updatePieceLocations();
                                }, 800);
                            }, 50);
                        }
                    }
                }
            }
            
            unfreezeBoard();
        }

        function sendMoveRequest(from, to, isJump) {
            if (isNaN(from) || isNaN(to) || from === null || to === null) {
                console.error(`Invalid move parameters: from=${from}, to=${to}`);
                return;
            }
            
            if (jumpTimer) {
                clearTimeout(jumpTimer);
                jumpTimer = null;
            }
            
            if (!jumpSequence) {
                if (isJump) {
                    jumpSequence = `${from}-33-${to}`;
                    lastMovedPiece = to;
                    
                    jumpTimer = setTimeout(() => {
                        if (jumpSequence) {
                            const url = `https://palamedes.onrender.com/move?move=${jumpSequence}`;
                            freezeBoard();
                            
                            fetch(url)
                                .then(response => {
                                    console.log(`Move sent: ${jumpSequence}`);
                                    return response.text();
                                })
                                .then(data => {
                                    processApiResponse(data);
                                })
                                .catch(error => {
                                    console.error("Error sending move request:", error);
                                    unfreezeBoard(); 
                                });
                        }
                            
                        jumpSequence = null;
                        jumpTimer = null;
                        lastMovedPiece = null;
                    }, JUMP_TIMEOUT);
                } else {
                    const url = `https://palamedes.onrender.com/move?move=${from}-${to}`;
                    freezeBoard();
                    
                    fetch(url)
                        .then(response => {
                            console.log(`Move sent: ${from} -> ${to}`);
                            return response.text();
                        })
                        .then(data => {
                            processApiResponse(data);
                        })
                        .catch(error => {
                            console.error("Error sending move request:", error);
                            unfreezeBoard(); 
                        });
                }
            } else {
                if (from === lastMovedPiece) {
                    jumpSequence += `-33-${to}`;
                    lastMovedPiece = to;
                    
                    jumpTimer = setTimeout(() => {
                        if (jumpSequence) {
                            const url = `https://palamedes.onrender.com/move?move=${jumpSequence}`;
                            freezeBoard();
                            
                            fetch(url)
                                .then(response => {
                                    console.log(`Move sent: ${jumpSequence}`);
                                    return response.text();
                                })
                                .then(data => {
                                    processApiResponse(data);
                                })
                                .catch(error => {
                                    console.error("Error sending move request:", error);
                                    unfreezeBoard(); 
                                });
                        }
                            
                        jumpSequence = null;
                        jumpTimer = null;
                        lastMovedPiece = null;
                    }, JUMP_TIMEOUT);
                }
            }
        }

        window.addEventListener("resize", updatePiecePositions);

        // Make global functions available
        window.createPieces = createPieces;
        window.pieces = pieces;
        window.updatePiecePositions = updatePiecePositions;
        window.rebuildPiecesState = rebuildPiecesState;

        // Create pieces immediately
        createPieces();

        function createPieces() {
            [...redPieces, ...grayPieces].forEach(num => {
                let piece = document.createElement("div");
                piece.classList.add("piece");
                piece.classList.add(redPieces.includes(num) ? "red" : "gray");
                piece.dataset.position = num;
                pieces[num] = piece;
                document.body.appendChild(piece);
                
                piece.addEventListener("mousedown", dragStart);
            });
            
            setTimeout(() => {
                updatePiecePositions();
                rebuildPiecesState();
            }, 100);
        }
    }

    // Global pieces object
    let pieces = {};
    </script>
</body>
</html>
