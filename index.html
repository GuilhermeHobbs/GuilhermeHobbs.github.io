<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CheckersGPT</title>
<style>
    * {margin: 0; padding: 0; box-sizing: border-box;}
    body {display: flex; justify-content: center; align-items: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); margin: 0; font-family: 'Arial', sans-serif; position: relative; overflow-x: hidden; padding: 20px;}
    body::before {content: ''; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%), radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%), radial-gradient(circle at 40% 40%, rgba(120, 119, 198, 0.2) 0%, transparent 50%); animation: float 20s ease-in-out infinite; z-index: -1;}
    @keyframes float {0%, 100% {transform: translateY(0px) rotate(0deg);} 33% {transform: translateY(-20px) rotate(1deg);} 66% {transform: translateY(10px) rotate(-1deg);}}
    .game-container {background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 30px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); display: flex; align-items: center; gap: 40px; max-width: 1200px;}
    .board-container {width: 70vmin; height: 70vmin; max-width: 500px; max-height: 500px; position: relative; flex-shrink: 0;}
    .side-panel {display: flex; flex-direction: column; align-items: center; gap: 30px; min-width: 250px;}
    .board {display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%; height: 100%; border: 5px solid #2c3e50; border-radius: 10px; position: relative; overflow: hidden; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);}
    .square {display: flex; justify-content: center; align-items: center; font-size: calc(70vmin / 16); font-weight: bold; z-index: 0; position: relative; transition: all 0.3s ease;}
    .black {background-color: #8b4513; color: #f4f4f4; background-image: linear-gradient(45deg, rgba(0,0,0,0.1) 25%, transparent 25%), linear-gradient(-45deg, rgba(0,0,0,0.1) 25%, transparent 25%); background-size: 4px 4px;}
    .white {background-color: #f5deb3; color: #8b4513; font-weight: 600; text-shadow: 1px 1px 2px rgba(0,0,0,0.1);}
    .square:hover {filter: brightness(1.1);}
    .piece {width: 12%; height: 12%; border-radius: 50%; position: absolute; display: flex; justify-content: center; align-items: center; font-size: calc(70vmin / 15); font-weight: bold; opacity: 0.9; transition: all 0.3s ease; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);}
    .piece::before {content: ''; position: absolute; width: 40%; height: 40%; border-radius: 50%; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.4), transparent); top: 15%; left: 15%;}
    .piece:hover {transform: scale(1.1); box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);}
    .piece.red {cursor: grab; background: linear-gradient(145deg, #e74c3c, #c0392b); color: white; border: 3px solid #a93226;}
    .piece.white {cursor: not-allowed; opacity: 0.7; background: linear-gradient(145deg, #95a5a6, #7f8c8d); color: white; border: 3px solid #5d6d7e;}
    .red.king {background: linear-gradient(145deg, #f39c12, #d68910); border: 3px solid #b9770e; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), 0 0 20px rgba(243, 156, 18, 0.5);}
    .white.king {background: linear-gradient(145deg, #3498db, #2980b9); border: 3px solid #21618c; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3), 0 0 20px rgba(52, 152, 219, 0.5);}
    .piece.king::after {content: '♛'; position: absolute; font-size: 1.8em; color: rgba(255, 255, 255, 0.9); text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5); animation: crownPulse 2s ease-in-out infinite;}
    @keyframes crownPulse {0%, 100% {transform: scale(1);} 50% {transform: scale(1.1);}}
    .piece:active {transform: scale(0.95);}
    .piece.red:active {cursor: grabbing;}
    .frozen {pointer-events: none; opacity: 0.7;}
    .game-title {text-align: center; color: white; font-size: 2.5em; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); letter-spacing: 2px; margin-bottom: 10px;}
    #newGameBtn {background: linear-gradient(145deg, #3498db, #2980b9); color: white; border: none; padding: 15px 30px; font-size: 18px; font-weight: bold; border-radius: 50px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 6px 20px rgba(52, 152, 219, 0.3); text-transform: uppercase; letter-spacing: 1px; position: relative; overflow: hidden; min-width: 150px;}
    #newGameBtn:hover {transform: translateY(-2px); box-shadow: 0 8px 25px rgba(52, 152, 219, 0.4); background: linear-gradient(145deg, #5dade2, #3498db);}
    #newGameBtn:active {transform: translateY(0); box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);}
    #newGameBtn::before {content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent); transition: left 0.5s;}
    #newGameBtn:hover::before {left: 100%;}
    .empty-board-message {position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: rgba(139, 69, 19, 0.6); font-size: 1.2em; font-weight: bold; pointer-events: none; text-shadow: 1px 1px 2px rgba(255,255,255,0.3);}
    @media (max-width: 1024px) {.game-container {flex-direction: column; gap: 20px; padding: 20px;} .board-container {width: 80vmin; height: 80vmin;} .side-panel {min-width: auto; gap: 20px;}}
    @media (max-width: 768px) {.game-container {padding: 15px; margin: 10px;} .board-container {width: 85vmin; height: 85vmin; max-width: 400px; max-height: 400px;} .game-title {font-size: 2em;} #newGameBtn {padding: 12px 24px; font-size: 16px;}}
    @media (max-width: 480px) {.board-container {width: 90vmin; height: 90vmin; max-width: 350px; max-height: 350px;} .game-title {font-size: 1.5em;}}
    .loading {display: inline-block; width: 20px; height: 20px; border: 3px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; margin-left: 10px;}
    @keyframes spin {to {transform: rotate(360deg);}}
    @keyframes spin {to {transform: rotate(360deg);}}
    .footer {position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(0, 0, 0, 0.3); backdrop-filter: blur(5px); padding: 15px; text-align: center; z-index: 1000;}
    .footer a {color: white; text-decoration: none; font-size: 16px; font-weight: 500; transition: all 0.3s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);}
    .footer a:hover {color: #3498db; transform: translateY(-2px); text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);}
</style>
</head>
<body>
</style>
</head>
<body>
    <div class="game-container">
        <div class="board-container">
            <div class="board" id="board">
                <div class="empty-board-message" id="emptyMessage">Clique em "Novo Jogo" para começar</div>
            </div>
        </div>
        <div class="side-panel">
            <h1 class="game-title">CheckersGPT</h1>
            <h2>Agente para Jogo de Damas Inglesas baseado em GPT</h2>
            <h3>Por Guilherme Hobbs - PUC-Rio <br> https://github.com/GuilhermeHobbs/Palamedes</h3>
            <p><a href="https://www.megajogos.com.br/damas-inglesas-online/regras" target="_blank">Regras de Damas Inglesas</a></p> 
            <button id="newGameBtn"><span id="btnText">Novo Jogo</span></button>
        </div>
    </div>
    <div class="footer">  
    <a href="https://www.linkedin.com/in/guilherme-hobbs-a23411125/" target="_blank">Visite Meu LinkedIn</a>
    </div>
    <script>
    let pieces = {};
    document.addEventListener("DOMContentLoaded", () => {
        let gameInitialized = false;
        initializeEmptyBoard();
        document.getElementById("newGameBtn").addEventListener("click", () => {
            if (!gameInitialized) {initializeGame(); gameInitialized = true;} 
            else {restartGame();}
        });
    });
    function initializeEmptyBoard() {
        const board = document.getElementById("board");
        const boardSize = 8;
        let whiteCounter = 1;
        board.innerHTML = '<div class="empty-board-message" id="emptyMessage">Clique em "Novo Jogo" para começar</div>';
        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                let square = document.createElement("div");
                square.classList.add("square");
                if ((row + col) % 2 === 0) {square.classList.add("black");} 
                else {square.classList.add("white"); square.dataset.position = whiteCounter; whiteCounter++;}
                board.appendChild(square);
            }
        }
    }
    function showLoading() {document.getElementById("btnText").innerHTML = 'Iniciando... <div class="loading"></div>'; document.getElementById("newGameBtn").disabled = true;}
    function hideLoading() {document.getElementById("btnText").textContent = "Novo Jogo"; document.getElementById("newGameBtn").disabled = false;}
    function restartGame() {
        showLoading();
        Object.values(pieces).forEach(piece => {piece.remove();});
        pieces = {};
        fetch(`http://3.17.57.133:10000/move?move=`).then(r => r.text()).then(data => {hideLoading(); createPieces();}).catch(e => {hideLoading(); createPieces();});
    }
    function initializeGame() {
        showLoading();
        const emptyMessage = document.getElementById("emptyMessage");
        if (emptyMessage) {emptyMessage.style.display = "none";}
        fetch(`http://3.17.57.133:10000/move?move=`).then(r => r.text()).then(data => {hideLoading(); setupGameLogic();}).catch(e => {hideLoading(); setupGameLogic();});
    }
    function setupGameLogic() {
        const board = document.getElementById("board");
        const boardContainer = document.querySelector(".board-container");
        const redPieces = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
        const whitePieces = [21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32];
        let boardFrozen = false;
        let jumpSequence = null;
        let jumpTimer = null;
        let lastMovedPiece = null;
        const JUMP_TIMEOUT = 4000;
        let pieceLocations = {};
        let piecesByPosition = {};
        function checkAndCrownPiece(piece, position) {
            const isRed = piece.classList.contains('red');
            const isWhite = piece.classList.contains('white');
            if (isRed && position >= 29 && position <= 32 && !piece.classList.contains('king')) {piece.classList.add('king');} 
            else if (isWhite && position >= 1 && position <= 4 && !piece.classList.contains('king')) {piece.classList.add('king');}
        }
        function updatePieceLocations() {
            pieceLocations = {};
            piecesByPosition = {};
            Object.entries(pieces).forEach(([id, piece]) => {
                const position = parseInt(piece.dataset.position);
                pieceLocations[id] = position;
                piecesByPosition[position] = piece;
            });
            console.log(`Updated piece locations:`, piecesByPosition);
        }
        function rebuildPiecesState() {
            let positionsOccupied = {};
            let piecesToRemove = [];
            Object.entries(pieces).forEach(([id, piece]) => {
                const position = parseInt(piece.dataset.position);
                if (positionsOccupied[position]) {piecesToRemove.push(id);} 
                else {positionsOccupied[position] = id;}
            });
            piecesToRemove.forEach(id => {if (pieces[id]) {pieces[id].remove(); delete pieces[id];}});
            updatePieceLocations();
        }
        function removePieceAtPosition(position) {
            position = parseInt(position);
            console.log(`Attempting to remove piece at position ${position}`);
            let pieceToRemove = piecesByPosition[position];
            if (!pieceToRemove) {pieceToRemove = Object.values(pieces).find(piece => parseInt(piece.dataset.position) === position);}
            if (pieceToRemove) {
                console.log(`Found piece at ${position}, removing it`);
                pieceToRemove.style.transition = "opacity 0.5s ease";
                pieceToRemove.style.opacity = "0";
                const pieceId = Object.keys(pieces).find(id => pieces[id] === pieceToRemove);
                setTimeout(() => {pieceToRemove.remove(); if (pieceId) {delete pieces[pieceId];} updatePieceLocations();}, 500);
                return true;
            }
            console.log(`No piece found at position ${position}`);
            return false;
        }
        function positionPiece(piece, position, animated = false) {
            let square = document.querySelector(`[data-position="${position}"]`);
            if (!square) {return;}
            let rect = square.getBoundingClientRect();
            let boardRect = boardContainer.getBoundingClientRect();
            let size = boardRect.width / 8;
            if (animated) {piece.style.transition = "left 0.8s ease, top 0.8s ease";} 
            else {piece.style.transition = "none";}
            piece.style.width = `${size * 0.75}px`;
            piece.style.height = `${size * 0.75}px`;
            piece.style.left = `${rect.left + window.scrollX + size * 0.125}px`;
            piece.style.top = `${rect.top + window.scrollY + size * 0.125}px`;
            piece.style.position = "absolute";
            if (!animated) {void piece.offsetWidth;}
        }
        function updatePiecePositions() {Object.values(pieces).forEach(piece => {let position = piece.dataset.position; positionPiece(piece, position, false);}); updatePieceLocations();}
        let draggedPiece = null;
        let offsetX = 0, offsetY = 0;
        let initialPosition = null;
        function dragStart(event) {
            if (boardFrozen) return;
            if (event.target.classList.contains('white')) return;
            draggedPiece = event.target;
            initialPosition = draggedPiece.dataset.position;
            offsetX = event.clientX - draggedPiece.getBoundingClientRect().left;
            offsetY = event.clientY - draggedPiece.getBoundingClientRect().top;
            document.addEventListener("mousemove", dragMove);
            document.addEventListener("mouseup", dragEnd);
        }
        function dragMove(event) {
            if (!draggedPiece || boardFrozen) return;
            draggedPiece.style.left = `${event.clientX - offsetX}px`;
            draggedPiece.style.top = `${event.clientY - offsetY}px`;
        }
        function dragEnd(event) {
            if (!draggedPiece || boardFrozen) return;
            let closestSquare = null;
            let minDistance = Infinity;
            document.querySelectorAll(".white").forEach(square => {
                let rect = square.getBoundingClientRect();
                let centerX = rect.left + rect.width / 2;
                let centerY = rect.top + rect.height / 2;
                let distance = Math.hypot(centerX - (draggedPiece.getBoundingClientRect().left + draggedPiece.clientWidth / 2), centerY - (draggedPiece.getBoundingClientRect().top + draggedPiece.clientHeight / 2));
                if (distance < minDistance) {minDistance = distance; closestSquare = square;}
            });
            if (closestSquare) {
                let newPosition = parseInt(closestSquare.dataset.position);
                let fromPosition = parseInt(initialPosition);
                if (newPosition !== fromPosition) {
                    positionPiece(draggedPiece, newPosition, false);
                    draggedPiece.dataset.position = newPosition;
                    updatePieceLocations();
                    checkAndCrownPiece(draggedPiece, newPosition);
                    let isJump = Math.abs(fromPosition - newPosition) === 9 || Math.abs(fromPosition - newPosition) === 7;
                    if (isJump) {
                        sendMoveRequest(fromPosition, newPosition, true);
                    } else {
                        sendMoveRequest(fromPosition, newPosition, false);
                    }
                } else {positionPiece(draggedPiece, fromPosition, false);}
            } else {positionPiece(draggedPiece, initialPosition, false);}
            draggedPiece = null;
            document.removeEventListener("mousemove", dragMove);
            document.removeEventListener("mouseup", dragEnd);
        }
        function freezeBoard() {boardFrozen = true; document.body.classList.add("frozen");}
        function unfreezeBoard() {boardFrozen = false; document.body.classList.remove("frozen");}
        
        function parseApiResponse(data) {
            const segments = [];
            const piecesToRemove = [];
            
            // Split by -33 to find jump segments
            const parts = data.split('-33-');
            
            for (let i = 0; i < parts.length; i++) {
                let part = parts[i];
                
                // Check if this part has pieces to remove in parentheses at the end
                const removalMatch = part.match(/^(.+)\(([0-9,]+)\)$/);
                
                if (removalMatch) {
                    // Extract the position and the pieces to remove
                    const position = removalMatch[1];
                    const toRemove = removalMatch[2].split(',').map(n => parseInt(n.trim()));
                    piecesToRemove.push(...toRemove);
                    part = position;
                }
                
                if (i === 0) {
                    // First part is just the starting position
                    if (parts.length > 1) {
                        segments.push({
                            from: parseInt(part),
                            to: null
                        });
                    }
                } else {
                    // Subsequent parts are destinations
                    segments[segments.length - 1].to = parseInt(part);
                    
                    if (i < parts.length - 1) {
                        // This destination becomes the next starting position
                        segments.push({
                            from: parseInt(part),
                            to: null
                        });
                    }
                }
            }
            
            // If it's not a jump sequence, handle as simple move
            if (!data.includes('-33-')) {
                // Check for removal syntax at the end: e.g., "11-18(14,20)"
                const simpleRemovalMatch = data.match(/^(\d+)-(\d+)\(([0-9,]+)\)$/);
                if (simpleRemovalMatch) {
                    const from = parseInt(simpleRemovalMatch[1]);
                    const to = parseInt(simpleRemovalMatch[2]);
                    const toRemove = simpleRemovalMatch[3].split(',').map(n => parseInt(n.trim()));
                    piecesToRemove.push(...toRemove);
                    segments.push({from, to});
                } else {
                    // Regular simple move
                    const [from, to] = data.split('-').map(Number);
                    if (!isNaN(from) && !isNaN(to)) {
                        segments.push({from, to});
                    }
                }
            }
            
            return {segments, piecesToRemove};
        }
        
        function processSegments(segments, piecesToRemove, index) {
            if (index >= segments.length) {
                // After all moves, remove the specified pieces
                if (piecesToRemove.length > 0) {
                    setTimeout(() => {
                        piecesToRemove.forEach(pos => {
                            removePieceAtPosition(pos);
                        });
                        setTimeout(() => {
                            unfreezeBoard();
                        }, 600);
                    }, 400);
                } else {
                    unfreezeBoard();
                }
                return;
            }
            
            const segment = segments[index];
            updatePieceLocations();
            
            let pieceToMove = piecesByPosition[segment.from];
            if (!pieceToMove) {pieceToMove = Object.values(pieces).find(piece => parseInt(piece.dataset.position) === segment.from);}
            
            if (!pieceToMove) {
                console.log(`No piece found at position ${segment.from}, skipping to next jump`);
                setTimeout(() => {processSegments(segments, piecesToRemove, index + 1);}, 100);
                return;
            }
            
            console.log(`Processing move: ${segment.from} -> ${segment.to}`);
            
            setTimeout(() => {
                pieceToMove.dataset.position = segment.to;
                positionPiece(pieceToMove, segment.to, true);
                
                setTimeout(() => {
                    checkAndCrownPiece(pieceToMove, segment.to);
                    updatePieceLocations();
                    
                    if (index + 1 < segments.length) {
                        setTimeout(() => {processSegments(segments, piecesToRemove, index + 1);}, 600);
                    } else {
                        processSegments(segments, piecesToRemove, index + 1);
                    }
                }, 400);
            }, 50);
        }
        
        function processApiResponse(data) {
            if (data && data.includes('-')) {
                rebuildPiecesState();
                console.log(`Processing API response: ${data}`);
                
                const {segments, piecesToRemove} = parseApiResponse(data);
                console.log('Parsed segments:', segments);
                console.log('Pieces to remove:', piecesToRemove);
                
                if (segments.length > 0) {
                    processSegments(segments, piecesToRemove, 0);
                } else {
                    unfreezeBoard();
                }
            } else {
                unfreezeBoard();
            }
        }
        
        function sendMoveRequest(from, to, isJump) {
            if (isNaN(from) || isNaN(to)) {return;}
            if (jumpTimer) {clearTimeout(jumpTimer); jumpTimer = null;}
            
            if (!jumpSequence) {
                if (isJump) {
                    jumpSequence = `${from}-33-${to}`;
                    lastMovedPiece = to;
                    jumpTimer = setTimeout(() => {
                        if (jumpSequence) {
                            const url = `http://3.17.57.133:10000/move?move=${jumpSequence}`;
                            freezeBoard();
                            fetch(url).then(r => r.text()).then(data => {processApiResponse(data);}).catch(e => {unfreezeBoard();});
                        }
                        jumpSequence = null; jumpTimer = null; lastMovedPiece = null;
                    }, JUMP_TIMEOUT);
                } else {
                    const url = `http://3.17.57.133:10000/move?move=${from}-${to}`;
                    freezeBoard();
                    fetch(url).then(r => r.text()).then(data => {processApiResponse(data);}).catch(e => {unfreezeBoard();});
                }
            } else {
                if (from === lastMovedPiece) {
                    jumpSequence += `-33-${to}`;
                    lastMovedPiece = to;
                    jumpTimer = setTimeout(() => {
                        if (jumpSequence) {
                            const url = `http://3.17.57.133:10000/move?move=${jumpSequence}`;
                            freezeBoard();
                            fetch(url).then(r => r.text()).then(data => {processApiResponse(data);}).catch(e => {unfreezeBoard();});
                        }
                        jumpSequence = null; jumpTimer = null; lastMovedPiece = null;
                    }, JUMP_TIMEOUT);
                }
            }
        }
        
        window.addEventListener("resize", updatePiecePositions);
        window.createPieces = createPieces;
        window.updatePiecePositions = updatePiecePositions;
        window.rebuildPiecesState = rebuildPiecesState;
        createPieces();
        
        function createPieces() {
            [...redPieces, ...whitePieces].forEach(num => {
                let piece = document.createElement("div");
                piece.classList.add("piece");
                piece.classList.add(redPieces.includes(num) ? "red" : "white");
                piece.dataset.position = num;
                pieces[num] = piece;
                document.body.appendChild(piece);
                if (piece.classList.contains('red')) {piece.addEventListener("mousedown", dragStart);}
            });
            setTimeout(() => {updatePiecePositions(); rebuildPiecesState();}, 100);
        }
    }
    </script>
</body>
</html>